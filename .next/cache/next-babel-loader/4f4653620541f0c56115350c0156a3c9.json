{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport ConnectyCube from 'connectycube';\nimport Dialog from '../models/dialogs';\nimport { fetchDialogs, sortDialogs, updateDialog, addNewDialog } from '../actions/dialogs';\nimport { pushMessage, setMessages, lazyFetchMessages, updateMessages } from '../actions/messages';\nimport { preparationAttachment } from '../helpers/file';\nimport { selectedDialog } from '../actions/selectedDialog';\nimport { fetchUsers } from '../actions/users';\nimport store from '../store';\nimport { Message, FakeMessage } from '../models/message';\nimport UserModel from '../models/user';\nimport { DIALOG_TYPE } from '../helpers/constants';\nimport { STATUS_DELIVERED, STATUS_READ, STATUS_SENT, GROUP_CHAT_ALERT_TYPE } from '../models/message';\n\nclass ChatService {\n  constructor() {\n    _defineProperty(this, \"getMoreMessages\", async dialog => {\n      const currentMessages = this.getMessagesByDialogId(dialog.id);\n      const lastMessageDate = currentMessages[0];\n      const updateObj = Object.assign(dialog, {\n        last_messages_for_fetch: lastMessageDate.date_sent\n      });\n      const filter = {\n        chat_dialog_id: dialog.id,\n        date_sent: {\n          lt: lastMessageDate.date_sent\n        },\n        sort_desc: 'date_sent'\n      };\n      const moreHistoryFromServer = await ConnectyCube.chat.message.list(filter);\n      const messages = [];\n      moreHistoryFromServer.items.forEach(elem => {\n        if (!elem.group_chat_alert_type) {\n          messages.push(new Message(elem, this.currentUser.id));\n        }\n      });\n      store.dispatch(updateDialog(updateObj));\n      const amountMessages = store.dispatch(lazyFetchMessages(dialog.id, messages));\n      return amountMessages.history.length;\n    });\n\n    _defineProperty(this, \"sendMsgChatAlertOnCreate\", async (dialog, message, alertType) => {\n      const date = Math.floor(Date.now() / 1000);\n      const recipient_id = dialog.type === DIALOG_TYPE.PRIVATE ? dialog.occupants_ids.find(elem => elem != this.currentUser.id) : dialog.xmpp_room_jid;\n      const messageExtensions = {\n        date_sent: date,\n        save_to_history: 1,\n        dialog_id: dialog.id,\n        group_chat_alert_type: alertType,\n        sender_id: this.currentUser.id\n      };\n      const msg = {\n        type: !dialog.xmpp_room_jid ? 'chat' : 'groupchat',\n        body: message,\n        extension: messageExtensions\n      };\n      ConnectyCube.chat.send(recipient_id, msg);\n    });\n\n    _defineProperty(this, \"updateDialogsUnreadMessagesCount\", dialog => {\n      const updateObj = Object.assign(dialog, {\n        unread_messages_count: 0\n      });\n      store.dispatch(updateDialog(updateObj));\n      return true;\n    });\n  }\n\n  setUpListeners() {\n    ConnectyCube.chat.onMessageListener = this.onMessageListener.bind(this);\n    ConnectyCube.chat.onSentMessageCallback = this.onSentMessageListener.bind(this);\n    ConnectyCube.chat.onDeliveredStatusListener = this.onDeliveredStatus.bind(this);\n    ConnectyCube.chat.onReadStatusListener = this.onReadStatus.bind(this);\n  }\n\n  async fetchDialogsFromServer() {\n    if (store.getState().dialogs.length !== 0) {\n      return store.getState().dialogs;\n    }\n\n    console.log('in fetch');\n    const dialogsFromServer = await ConnectyCube.chat.dialog.list(); // const currentUserId = this.currentUser\n    // let privatChatIdsUser = []\n\n    const dialogs = dialogsFromServer.items.map(elem => {\n      // if (elem.type === DIALOG_TYPE.PRIVATE) {\n      //   elem.occupants_ids.forEach(elem => {\n      //     elem !== currentUserId.id && privatChatIdsUser.push(elem)\n      //   })\n      // }\n      return new Dialog(elem);\n    }); // if (privatChatIdsUser.length !== 0) {\n    //   const usersInfo = await this.getUsersList(privatChatIdsUser)\n    //   store.dispatch(fetchUsers(usersInfo))\n    // }\n\n    store.dispatch(fetchDialogs(dialogs));\n    return store.getState().dialogs;\n  }\n\n  async getMessages(dialog) {\n    const isAlredyUpdate = this.getMessagesByDialogId(dialog.id);\n    let amountMessages = null; // If the first entry into the chat\n\n    if (!dialog.isAlreadyMessageFetch || dialog.unread_messages_count > 0 && !dialog.isAlreadyMessageFetch) {\n      const historyFromServer = await ConnectyCube.chat.message.list({\n        chat_dialog_id: dialog.id,\n        sort_desc: 'date_sent'\n      });\n      const messages = [];\n      historyFromServer.items.forEach(elem => {\n        if (!elem.group_chat_alert_type) {\n          messages.push(new Message(elem, this.currentUser.id));\n        }\n      });\n      const newObj = Object.assign(dialog, {\n        isAlreadyMessageFetch: true\n      });\n      this.updateDialogsUnreadMessagesCount(newObj);\n      store.dispatch(setMessages(dialog.id, messages));\n      amountMessages = messages.length;\n    } else {\n      // If the second entry into the chat\n      if (dialog.unread_messages_count > 0) {\n        const messages = this.getMessagesByDialogId(dialog.id);\n        const firstUnreadMsg = messages[dialog.unread_messages_count - 1];\n        this.readAllMessages(dialog.id);\n        await this.sendReadStatus(firstUnreadMsg.id, firstUnreadMsg.sender_id, firstUnreadMsg.dialog_id);\n        this.updateDialogsUnreadMessagesCount(dialog);\n      }\n\n      amountMessages = isAlredyUpdate.length;\n    }\n\n    return amountMessages;\n  } // Message loading if more than 100\n\n\n  async sendMessage(dialog, messageText, attachments = false, scrollToBottom) {\n    const user = this.currentUser;\n    const text = messageText.trim();\n    const date = Math.floor(Date.now() / 1000);\n    const recipient_id = dialog.type === DIALOG_TYPE.PRIVATE ? dialog.occupants_ids.find(elem => elem != user.id) : dialog.xmpp_room_jid;\n    let msg = {\n      type: dialog.xmpp_type,\n      body: text,\n      extension: {\n        save_to_history: 1,\n        dialog_id: dialog.id,\n        sender_id: user.id,\n        date_sent: date\n      } // markable: 1\n\n    };\n    msg.id = this.messageUniqueId; // If send message as Attachment\n\n    if (attachments) {\n      return this.sendMessageAsAttachment(dialog, recipient_id, msg, attachments, scrollToBottom);\n    }\n\n    const message = new FakeMessage(msg);\n    const newObjFreez = Object.freeze(message);\n    await store.dispatch(pushMessage(newObjFreez, dialog.id));\n    scrollToBottom();\n    ConnectyCube.chat.send(recipient_id, msg);\n    store.dispatch(sortDialogs(newObjFreez));\n  }\n\n  sendChatAlertOnCreate(dialog) {\n    const message = 'Group is created';\n    this.sendMsgChatAlertOnCreate(dialog, message, GROUP_CHAT_ALERT_TYPE.CREATE);\n  }\n\n  async sendMessageAsAttachment(dialog, recipient_id, msg, attachments, scrollToBottom) {\n    //create fake data for render img\n    const url = URL.createObjectURL(attachments.file);\n    msg.extension.attachments = [{\n      url\n    }];\n    msg.body = 'Image attachment';\n    const message = new FakeMessage(msg);\n    await store.dispatch(pushMessage(message, dialog.id));\n    scrollToBottom(); // create real data for attachment\n\n    const response = await this.uploadPhoto(attachments);\n    const newObjAttach = preparationAttachment(response);\n    msg.extension.attachments = [newObjAttach];\n    await ConnectyCube.chat.send(recipient_id, msg);\n    store.dispatch(sortDialogs(message));\n    return;\n  }\n\n  async createPrivateDialog(userId) {\n    const dialogs = store.getState().dialogs;\n    let dialog = null;\n    dialogs.forEach(elem => {\n      if (elem.type === DIALOG_TYPE.PRIVATE && elem.occupants_ids.find(elem => elem === userId)) {\n        dialog = elem;\n      }\n    });\n\n    if (!dialog) {\n      const params = {\n        type: DIALOG_TYPE.PRIVATE,\n        occupants_ids: userId\n      };\n      const response = await ConnectyCube.chat.dialog.create(params);\n      dialog = new Dialog(response);\n\n      if (this.getUserFromReduxById(userId)) {\n        store.dispatch(addNewDialog(dialog));\n        return dialog;\n      } else {\n        const usersInfo = await this.getUserFromServerById(userId);\n        usersInfo.user = new UserModel(usersInfo.user);\n        store.dispatch(fetchUsers([usersInfo.user]));\n        store.dispatch(addNewDialog(dialog));\n        return dialog;\n      }\n    } // If the user is already in the Redux\n\n\n    if (this.getUserFromReduxById(userId)) {\n      return dialog;\n    } else {\n      const usersInfo = await this.getUserFromServerById(userId);\n      usersInfo.user = new UserModel(usersInfo.user);\n      store.dispatch(fetchUsers([usersInfo.user]));\n      return dialog;\n    }\n  }\n\n  async createPublicDialog(occupants_ids, groupName, img) {\n    const currentUser = this.currentUser;\n    occupants_ids.unshift(currentUser.id);\n    const params = {\n      type: DIALOG_TYPE.GROUP,\n      occupants_ids,\n      name: groupName\n    };\n    const image = img ? await this.uploadPhoto(img) : null;\n\n    if (image) {\n      params.photo = image.uid;\n    }\n\n    const dialog = await ConnectyCube.chat.dialog.create(params);\n    const newDialog = new Dialog(dialog);\n    store.dispatch(addNewDialog(newDialog));\n    return newDialog;\n  }\n\n  async readAllMessages(dialogId) {\n    return ConnectyCube.chat.message.update(null, {\n      chat_dialog_id: dialogId,\n      read: 1\n    });\n  }\n\n  async readMessage(messageId, dialogId) {\n    this.onReadStatus(messageId, dialogId);\n    return ConnectyCube.chat.message.update(null, {\n      chat_dialog_id: dialogId,\n      read: 1\n    });\n  }\n\n  async onMessageListener(senderId, msg) {\n    var _this$getSelectedDial;\n\n    const message = new Message(msg);\n    const user = this.currentUser;\n    const dialog = (_this$getSelectedDial = this.getSelectedDialog()) === null || _this$getSelectedDial === void 0 ? void 0 : _this$getSelectedDial.id; // If group chat alet\n\n    if (msg.extension.group_chat_alert_type) {\n      const dialogsFromServer = await ConnectyCube.chat.dialog.list();\n      const dialogs = dialogsFromServer.items.map(elem => {\n        return new Dialog(elem);\n      });\n      store.dispatch(fetchDialogs(dialogs));\n      return;\n    }\n\n    if (senderId !== user.id) {\n      if (dialog === message.dialog_id) {\n        store.dispatch(sortDialogs(message));\n        this.readMessage(message.id, message.dialog_id);\n        this.sendReadStatus(msg.extension.message_id, msg.extension.sender_id, msg.dialog_id);\n      } else {\n        this.sendDeliveredStatus(msg.extension.message_id, msg.extension.sender_id, msg.dialog_id);\n        store.dispatch(sortDialogs(message, true));\n      }\n\n      store.dispatch(pushMessage(message, message.dialog_id));\n    }\n  } // ConnectyCube listeners\n\n\n  onSentMessageListener(failedMessage, msg) {\n    console.warn('onSentMessageListener');\n\n    if (failedMessage || msg.extension.group_chat_alert_type) {\n      return;\n    }\n\n    store.dispatch(updateMessages(msg.extension.dialog_id, msg.id, {\n      send_state: STATUS_SENT\n    }));\n  }\n\n  onDeliveredStatus(messageId, dialogId, userId) {\n    console.warn('onDeliveredStatus', messageId);\n    store.dispatch(updateMessages(dialogId, messageId, {\n      send_state: STATUS_DELIVERED\n    }));\n  }\n\n  onReadStatus(messageId, dialogId, userId) {\n    console.warn('onReadStatus', messageId);\n    store.dispatch(updateMessages(dialogId, messageId, {\n      send_state: STATUS_READ\n    }));\n  }\n\n  sendReadStatus(messageId, userId, dialogId) {\n    ConnectyCube.chat.sendReadStatus({\n      messageId,\n      userId,\n      dialogId\n    });\n  }\n\n  sendDeliveredStatus(messageId, userId, dialogId) {\n    ConnectyCube.chat.sendDeliveredStatus({\n      messageId,\n      userId,\n      dialogId\n    });\n  }\n\n  async getUsersList(ids) {\n    const usersList = await ConnectyCube.users.get({\n      per_page: 100,\n      filter: {\n        field: 'id',\n        param: 'in',\n        value: ids\n      }\n    });\n    return usersList.items.map(elem => {\n      return new UserModel(elem.user);\n    });\n  }\n\n  async getUserFromServerById(id) {\n    return ConnectyCube.users.get(id);\n  }\n\n  setSelectDialog(dialog) {\n    store.dispatch(selectedDialog(dialog));\n  }\n\n  getSelectedDialog() {\n    return store.getState().selectedDialog;\n  }\n\n  getDialogById(dialogId) {\n    return store.getState().dialogs.find(elem => elem.id === dialogId);\n  }\n\n  getMessagesByDialogId(dialogId) {\n    const result = store.getState().messages;\n    return result[dialogId];\n  }\n\n  async uploadPhoto(file) {\n    return ConnectyCube.storage.createAndUpload(file);\n  }\n\n  get currentUser() {\n    return store.getState().currentUser.user;\n  }\n\n  getUserFromReduxById(id) {\n    return store.getState().users[id];\n  }\n\n  get messageUniqueId() {\n    return ConnectyCube.chat.helpers.getBsonObjectId();\n  }\n\n}\n\nconst chatService = new ChatService();\nObject.freeze(chatService);\nexport default chatService;","map":null,"metadata":{},"sourceType":"module"}