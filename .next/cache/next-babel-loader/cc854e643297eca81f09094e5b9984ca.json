{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport ConnectyCube from 'connectycube';\nimport Dialog from '../models/dialogs';\nimport { fetchDialogs, sortDialogs, updateDialog, addNewDialog } from '../actions/dialogs';\nimport { pushMessage, setMessages, lazyFetchMessages, updateMessages } from '../actions/messages';\nimport { preparationAttachment } from '../helpers/file';\nimport { selectedDialog } from '../actions/selectedDialog';\nimport { fetchUsers } from '../actions/users';\nimport store from '../store';\nimport { Message, FakeMessage } from '../models/message';\nimport UserModel from '../models/user';\nimport { DIALOG_TYPE } from '../helpers/constants';\nimport { STATUS_DELIVERED, STATUS_READ, STATUS_SENT, GROUP_CHAT_ALERT_TYPE } from '../models/message';\n\nvar ChatService = /*#__PURE__*/function () {\n  function ChatService() {\n    var _this = this;\n\n    _classCallCheck(this, ChatService);\n\n    _defineProperty(this, \"getMoreMessages\", /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(dialog) {\n        var currentMessages, lastMessageDate, updateObj, filter, moreHistoryFromServer, messages, amountMessages;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                currentMessages = _this.getMessagesByDialogId(dialog.id);\n                lastMessageDate = currentMessages[0];\n                updateObj = Object.assign(dialog, {\n                  last_messages_for_fetch: lastMessageDate.date_sent\n                });\n                filter = {\n                  chat_dialog_id: dialog.id,\n                  date_sent: {\n                    lt: lastMessageDate.date_sent\n                  },\n                  sort_desc: 'date_sent'\n                };\n                _context.next = 6;\n                return ConnectyCube.chat.message.list(filter);\n\n              case 6:\n                moreHistoryFromServer = _context.sent;\n                messages = [];\n                moreHistoryFromServer.items.forEach(function (elem) {\n                  if (!elem.group_chat_alert_type) {\n                    messages.push(new Message(elem, _this.currentUser.id));\n                  }\n                });\n                store.dispatch(updateDialog(updateObj));\n                amountMessages = store.dispatch(lazyFetchMessages(dialog.id, messages));\n                return _context.abrupt(\"return\", amountMessages.history.length);\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n\n    _defineProperty(this, \"sendMsgChatAlertOnCreate\", /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(dialog, message, alertType) {\n        var date, recipient_id, messageExtensions, msg;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                date = Math.floor(Date.now() / 1000);\n                recipient_id = dialog.type === DIALOG_TYPE.PRIVATE ? dialog.occupants_ids.find(function (elem) {\n                  return elem != _this.currentUser.id;\n                }) : dialog.xmpp_room_jid;\n                messageExtensions = {\n                  date_sent: date,\n                  save_to_history: 1,\n                  dialog_id: dialog.id,\n                  group_chat_alert_type: alertType,\n                  sender_id: _this.currentUser.id\n                };\n                msg = {\n                  type: !dialog.xmpp_room_jid ? 'chat' : 'groupchat',\n                  body: message,\n                  extension: messageExtensions\n                };\n                ConnectyCube.chat.send(recipient_id, msg);\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function (_x2, _x3, _x4) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n\n    _defineProperty(this, \"updateDialogsUnreadMessagesCount\", function (dialog) {\n      var updateObj = Object.assign(dialog, {\n        unread_messages_count: 0\n      });\n      store.dispatch(updateDialog(updateObj));\n      return true;\n    });\n  }\n\n  _createClass(ChatService, [{\n    key: \"setUpListeners\",\n    value: function setUpListeners() {\n      ConnectyCube.chat.onMessageListener = this.onMessageListener.bind(this);\n      ConnectyCube.chat.onSentMessageCallback = this.onSentMessageListener.bind(this);\n      ConnectyCube.chat.onDeliveredStatusListener = this.onDeliveredStatus.bind(this);\n      ConnectyCube.chat.onReadStatusListener = this.onReadStatus.bind(this);\n    }\n  }, {\n    key: \"fetchDialogsFromServer\",\n    value: function () {\n      var _fetchDialogsFromServer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var dialogsFromServer, dialogs;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(store.getState().dialogs.length !== 0)) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", store.getState().dialogs);\n\n              case 2:\n                console.log('in fetch');\n                _context3.next = 5;\n                return ConnectyCube.chat.dialog.list();\n\n              case 5:\n                dialogsFromServer = _context3.sent;\n                // const currentUserId = this.currentUser\n                // let privatChatIdsUser = []\n                dialogs = dialogsFromServer.items.map(function (elem) {\n                  // if (elem.type === DIALOG_TYPE.PRIVATE) {\n                  //   elem.occupants_ids.forEach(elem => {\n                  //     elem !== currentUserId.id && privatChatIdsUser.push(elem)\n                  //   })\n                  // }\n                  return new Dialog(elem);\n                }); // if (privatChatIdsUser.length !== 0) {\n                //   const usersInfo = await this.getUsersList(privatChatIdsUser)\n                //   store.dispatch(fetchUsers(usersInfo))\n                // }\n\n                store.dispatch(fetchDialogs(dialogs));\n                return _context3.abrupt(\"return\", store.getState().dialogs);\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function fetchDialogsFromServer() {\n        return _fetchDialogsFromServer.apply(this, arguments);\n      }\n\n      return fetchDialogsFromServer;\n    }()\n  }, {\n    key: \"getMessages\",\n    value: function () {\n      var _getMessages = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(dialog) {\n        var _this2 = this;\n\n        var isAlredyUpdate, amountMessages, historyFromServer, messages, newObj, _messages, firstUnreadMsg;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                isAlredyUpdate = this.getMessagesByDialogId(dialog.id);\n                amountMessages = null; // If the first entry into the chat\n\n                if (!(!dialog.isAlreadyMessageFetch || dialog.unread_messages_count > 0 && !dialog.isAlreadyMessageFetch)) {\n                  _context4.next = 14;\n                  break;\n                }\n\n                _context4.next = 5;\n                return ConnectyCube.chat.message.list({\n                  chat_dialog_id: dialog.id,\n                  sort_desc: 'date_sent'\n                });\n\n              case 5:\n                historyFromServer = _context4.sent;\n                messages = [];\n                historyFromServer.items.forEach(function (elem) {\n                  if (!elem.group_chat_alert_type) {\n                    messages.push(new Message(elem, _this2.currentUser.id));\n                  }\n                });\n                newObj = Object.assign(dialog, {\n                  isAlreadyMessageFetch: true\n                });\n                this.updateDialogsUnreadMessagesCount(newObj);\n                store.dispatch(setMessages(dialog.id, messages));\n                amountMessages = messages.length;\n                _context4.next = 22;\n                break;\n\n              case 14:\n                if (!(dialog.unread_messages_count > 0)) {\n                  _context4.next = 21;\n                  break;\n                }\n\n                _messages = this.getMessagesByDialogId(dialog.id);\n                firstUnreadMsg = _messages[dialog.unread_messages_count - 1];\n                this.readAllMessages(dialog.id);\n                _context4.next = 20;\n                return this.sendReadStatus(firstUnreadMsg.id, firstUnreadMsg.sender_id, firstUnreadMsg.dialog_id);\n\n              case 20:\n                this.updateDialogsUnreadMessagesCount(dialog);\n\n              case 21:\n                amountMessages = isAlredyUpdate.length;\n\n              case 22:\n                return _context4.abrupt(\"return\", amountMessages);\n\n              case 23:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getMessages(_x5) {\n        return _getMessages.apply(this, arguments);\n      }\n\n      return getMessages;\n    }() // Message loading if more than 100\n\n  }, {\n    key: \"sendMessage\",\n    value: function () {\n      var _sendMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(dialog, messageText) {\n        var attachments,\n            scrollToBottom,\n            user,\n            text,\n            date,\n            recipient_id,\n            msg,\n            message,\n            newObjFreez,\n            _args5 = arguments;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                attachments = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : false;\n                scrollToBottom = _args5.length > 3 ? _args5[3] : undefined;\n                user = this.currentUser;\n                text = messageText.trim();\n                date = Math.floor(Date.now() / 1000);\n                recipient_id = dialog.type === DIALOG_TYPE.PRIVATE ? dialog.occupants_ids.find(function (elem) {\n                  return elem != user.id;\n                }) : dialog.xmpp_room_jid;\n                msg = {\n                  type: dialog.xmpp_type,\n                  body: text,\n                  extension: {\n                    save_to_history: 1,\n                    dialog_id: dialog.id,\n                    sender_id: user.id,\n                    date_sent: date\n                  } // markable: 1\n\n                };\n                msg.id = this.messageUniqueId; // If send message as Attachment\n\n                if (!attachments) {\n                  _context5.next = 10;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", this.sendMessageAsAttachment(dialog, recipient_id, msg, attachments, scrollToBottom));\n\n              case 10:\n                message = new FakeMessage(msg);\n                newObjFreez = Object.freeze(message);\n                _context5.next = 14;\n                return store.dispatch(pushMessage(newObjFreez, dialog.id));\n\n              case 14:\n                scrollToBottom();\n                ConnectyCube.chat.send(recipient_id, msg);\n                store.dispatch(sortDialogs(newObjFreez));\n\n              case 17:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function sendMessage(_x6, _x7) {\n        return _sendMessage.apply(this, arguments);\n      }\n\n      return sendMessage;\n    }()\n  }, {\n    key: \"sendChatAlertOnCreate\",\n    value: function sendChatAlertOnCreate(dialog) {\n      var message = 'Group is created';\n      this.sendMsgChatAlertOnCreate(dialog, message, GROUP_CHAT_ALERT_TYPE.CREATE);\n    }\n  }, {\n    key: \"sendMessageAsAttachment\",\n    value: function () {\n      var _sendMessageAsAttachment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(dialog, recipient_id, msg, attachments, scrollToBottom) {\n        var url, message, response, newObjAttach;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                //create fake data for render img\n                url = URL.createObjectURL(attachments.file);\n                msg.extension.attachments = [{\n                  url: url\n                }];\n                msg.body = 'Image attachment';\n                message = new FakeMessage(msg);\n                _context6.next = 6;\n                return store.dispatch(pushMessage(message, dialog.id));\n\n              case 6:\n                scrollToBottom(); // create real data for attachment\n\n                _context6.next = 9;\n                return this.uploadPhoto(attachments);\n\n              case 9:\n                response = _context6.sent;\n                newObjAttach = preparationAttachment(response);\n                msg.extension.attachments = [newObjAttach];\n                _context6.next = 14;\n                return ConnectyCube.chat.send(recipient_id, msg);\n\n              case 14:\n                store.dispatch(sortDialogs(message));\n                return _context6.abrupt(\"return\");\n\n              case 16:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function sendMessageAsAttachment(_x8, _x9, _x10, _x11, _x12) {\n        return _sendMessageAsAttachment.apply(this, arguments);\n      }\n\n      return sendMessageAsAttachment;\n    }()\n  }, {\n    key: \"createPrivateDialog\",\n    value: function () {\n      var _createPrivateDialog = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(userId) {\n        var dialogs, dialog, params, response, usersInfo, _usersInfo;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                dialogs = store.getState().dialogs;\n                dialog = null;\n                dialogs.forEach(function (elem) {\n                  if (elem.type === DIALOG_TYPE.PRIVATE && elem.occupants_ids.find(function (elem) {\n                    return elem === userId;\n                  })) {\n                    dialog = elem;\n                  }\n                });\n\n                if (dialog) {\n                  _context7.next = 21;\n                  break;\n                }\n\n                params = {\n                  type: DIALOG_TYPE.PRIVATE,\n                  occupants_ids: userId\n                };\n                _context7.next = 7;\n                return ConnectyCube.chat.dialog.create(params);\n\n              case 7:\n                response = _context7.sent;\n                dialog = new Dialog(response);\n\n                if (!this.getUserFromReduxById(userId)) {\n                  _context7.next = 14;\n                  break;\n                }\n\n                store.dispatch(addNewDialog(dialog));\n                return _context7.abrupt(\"return\", dialog);\n\n              case 14:\n                _context7.next = 16;\n                return this.getUserFromServerById(userId);\n\n              case 16:\n                usersInfo = _context7.sent;\n                usersInfo.user = new UserModel(usersInfo.user);\n                store.dispatch(fetchUsers([usersInfo.user]));\n                store.dispatch(addNewDialog(dialog));\n                return _context7.abrupt(\"return\", dialog);\n\n              case 21:\n                if (!this.getUserFromReduxById(userId)) {\n                  _context7.next = 25;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", dialog);\n\n              case 25:\n                _context7.next = 27;\n                return this.getUserFromServerById(userId);\n\n              case 27:\n                _usersInfo = _context7.sent;\n                _usersInfo.user = new UserModel(_usersInfo.user);\n                store.dispatch(fetchUsers([_usersInfo.user]));\n                return _context7.abrupt(\"return\", dialog);\n\n              case 31:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function createPrivateDialog(_x13) {\n        return _createPrivateDialog.apply(this, arguments);\n      }\n\n      return createPrivateDialog;\n    }()\n  }, {\n    key: \"createPublicDialog\",\n    value: function () {\n      var _createPublicDialog = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(occupants_ids, groupName, img) {\n        var currentUser, params, image, dialog, newDialog;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                currentUser = this.currentUser;\n                occupants_ids.unshift(currentUser.id);\n                params = {\n                  type: DIALOG_TYPE.GROUP,\n                  occupants_ids: occupants_ids,\n                  name: groupName\n                };\n\n                if (!img) {\n                  _context8.next = 9;\n                  break;\n                }\n\n                _context8.next = 6;\n                return this.uploadPhoto(img);\n\n              case 6:\n                _context8.t0 = _context8.sent;\n                _context8.next = 10;\n                break;\n\n              case 9:\n                _context8.t0 = null;\n\n              case 10:\n                image = _context8.t0;\n\n                if (image) {\n                  params.photo = image.uid;\n                }\n\n                _context8.next = 14;\n                return ConnectyCube.chat.dialog.create(params);\n\n              case 14:\n                dialog = _context8.sent;\n                newDialog = new Dialog(dialog);\n                store.dispatch(addNewDialog(newDialog));\n                return _context8.abrupt(\"return\", newDialog);\n\n              case 18:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function createPublicDialog(_x14, _x15, _x16) {\n        return _createPublicDialog.apply(this, arguments);\n      }\n\n      return createPublicDialog;\n    }()\n  }, {\n    key: \"readAllMessages\",\n    value: function () {\n      var _readAllMessages = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(dialogId) {\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                return _context9.abrupt(\"return\", ConnectyCube.chat.message.update(null, {\n                  chat_dialog_id: dialogId,\n                  read: 1\n                }));\n\n              case 1:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9);\n      }));\n\n      function readAllMessages(_x17) {\n        return _readAllMessages.apply(this, arguments);\n      }\n\n      return readAllMessages;\n    }()\n  }, {\n    key: \"readMessage\",\n    value: function () {\n      var _readMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(messageId, dialogId) {\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                this.onReadStatus(messageId, dialogId);\n                return _context10.abrupt(\"return\", ConnectyCube.chat.message.update(null, {\n                  chat_dialog_id: dialogId,\n                  read: 1\n                }));\n\n              case 2:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function readMessage(_x18, _x19) {\n        return _readMessage.apply(this, arguments);\n      }\n\n      return readMessage;\n    }()\n  }, {\n    key: \"onMessageListener\",\n    value: function () {\n      var _onMessageListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(senderId, msg) {\n        var _this$getSelectedDial;\n\n        var message, user, dialog, dialogsFromServer, dialogs;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                message = new Message(msg);\n                user = this.currentUser;\n                dialog = (_this$getSelectedDial = this.getSelectedDialog()) === null || _this$getSelectedDial === void 0 ? void 0 : _this$getSelectedDial.id; // If group chat alet\n\n                if (!msg.extension.group_chat_alert_type) {\n                  _context11.next = 10;\n                  break;\n                }\n\n                _context11.next = 6;\n                return ConnectyCube.chat.dialog.list();\n\n              case 6:\n                dialogsFromServer = _context11.sent;\n                dialogs = dialogsFromServer.items.map(function (elem) {\n                  return new Dialog(elem);\n                });\n                store.dispatch(fetchDialogs(dialogs));\n                return _context11.abrupt(\"return\");\n\n              case 10:\n                if (senderId !== user.id) {\n                  if (dialog === message.dialog_id) {\n                    store.dispatch(sortDialogs(message));\n                    this.readMessage(message.id, message.dialog_id);\n                    this.sendReadStatus(msg.extension.message_id, msg.extension.sender_id, msg.dialog_id);\n                  } else {\n                    this.sendDeliveredStatus(msg.extension.message_id, msg.extension.sender_id, msg.dialog_id);\n                    store.dispatch(sortDialogs(message, true));\n                  }\n\n                  store.dispatch(pushMessage(message, message.dialog_id));\n                }\n\n              case 11:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function onMessageListener(_x20, _x21) {\n        return _onMessageListener.apply(this, arguments);\n      }\n\n      return onMessageListener;\n    }() // ConnectyCube listeners\n\n  }, {\n    key: \"onSentMessageListener\",\n    value: function onSentMessageListener(failedMessage, msg) {\n      console.warn('onSentMessageListener');\n\n      if (failedMessage || msg.extension.group_chat_alert_type) {\n        return;\n      }\n\n      store.dispatch(updateMessages(msg.extension.dialog_id, msg.id, {\n        send_state: STATUS_SENT\n      }));\n    }\n  }, {\n    key: \"onDeliveredStatus\",\n    value: function onDeliveredStatus(messageId, dialogId, userId) {\n      console.warn('onDeliveredStatus', messageId);\n      store.dispatch(updateMessages(dialogId, messageId, {\n        send_state: STATUS_DELIVERED\n      }));\n    }\n  }, {\n    key: \"onReadStatus\",\n    value: function onReadStatus(messageId, dialogId, userId) {\n      console.warn('onReadStatus', messageId);\n      store.dispatch(updateMessages(dialogId, messageId, {\n        send_state: STATUS_READ\n      }));\n    }\n  }, {\n    key: \"sendReadStatus\",\n    value: function sendReadStatus(messageId, userId, dialogId) {\n      ConnectyCube.chat.sendReadStatus({\n        messageId: messageId,\n        userId: userId,\n        dialogId: dialogId\n      });\n    }\n  }, {\n    key: \"sendDeliveredStatus\",\n    value: function sendDeliveredStatus(messageId, userId, dialogId) {\n      ConnectyCube.chat.sendDeliveredStatus({\n        messageId: messageId,\n        userId: userId,\n        dialogId: dialogId\n      });\n    }\n  }, {\n    key: \"getUsersList\",\n    value: function () {\n      var _getUsersList = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(ids) {\n        var usersList;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return ConnectyCube.users.get({\n                  per_page: 100,\n                  filter: {\n                    field: 'id',\n                    param: 'in',\n                    value: ids\n                  }\n                });\n\n              case 2:\n                usersList = _context12.sent;\n                return _context12.abrupt(\"return\", usersList.items.map(function (elem) {\n                  return new UserModel(elem.user);\n                }));\n\n              case 4:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12);\n      }));\n\n      function getUsersList(_x22) {\n        return _getUsersList.apply(this, arguments);\n      }\n\n      return getUsersList;\n    }()\n  }, {\n    key: \"getUserFromServerById\",\n    value: function () {\n      var _getUserFromServerById = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(id) {\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                return _context13.abrupt(\"return\", ConnectyCube.users.get(id));\n\n              case 1:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13);\n      }));\n\n      function getUserFromServerById(_x23) {\n        return _getUserFromServerById.apply(this, arguments);\n      }\n\n      return getUserFromServerById;\n    }()\n  }, {\n    key: \"setSelectDialog\",\n    value: function setSelectDialog(dialog) {\n      store.dispatch(selectedDialog(dialog));\n    }\n  }, {\n    key: \"getSelectedDialog\",\n    value: function getSelectedDialog() {\n      return store.getState().selectedDialog;\n    }\n  }, {\n    key: \"getDialogById\",\n    value: function getDialogById(dialogId) {\n      return store.getState().dialogs.find(function (elem) {\n        return elem.id === dialogId;\n      });\n    }\n  }, {\n    key: \"getMessagesByDialogId\",\n    value: function getMessagesByDialogId(dialogId) {\n      var result = store.getState().messages;\n      return result[dialogId];\n    }\n  }, {\n    key: \"uploadPhoto\",\n    value: function () {\n      var _uploadPhoto = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(file) {\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                return _context14.abrupt(\"return\", ConnectyCube.storage.createAndUpload(file));\n\n              case 1:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14);\n      }));\n\n      function uploadPhoto(_x24) {\n        return _uploadPhoto.apply(this, arguments);\n      }\n\n      return uploadPhoto;\n    }()\n  }, {\n    key: \"currentUser\",\n    get: function get() {\n      return store.getState().currentUser.user;\n    }\n  }, {\n    key: \"getUserFromReduxById\",\n    value: function getUserFromReduxById(id) {\n      return store.getState().users[id];\n    }\n  }, {\n    key: \"messageUniqueId\",\n    get: function get() {\n      return ConnectyCube.chat.helpers.getBsonObjectId();\n    }\n  }]);\n\n  return ChatService;\n}();\n\nvar chatService = new ChatService();\nObject.freeze(chatService);\nexport default chatService;","map":null,"metadata":{},"sourceType":"module"}